#include <stdio.h>
#include <stdint.h>

// Permutation tables
int P10[] = {3, 5, 2, 7, 4, 10, 1, 9, 8, 6};
int P8[] = {6, 3, 7, 4, 8, 5, 10, 9};
int P4[] = {2, 4, 3, 1};
int IP[] = {2, 6, 3, 1, 4, 8, 5, 7};
int IP_inv[] = {4, 1, 3, 5, 7, 2, 8, 6};
int EP[] = {4, 1, 2, 3, 2, 3, 4, 1};

// S-boxes
int S0[4][4] = {
    {1, 0, 3, 2},
    {3, 2, 1, 0},
    {0, 2, 1, 3},
    {3, 1, 3, 2}};
int S1[4][4] = {
    {0, 1, 2, 3},
    {2, 0, 1, 3},
    {3, 0, 1, 0},
    {2, 1, 0, 3}};

// Utility function to get bit at position
int get_bit(int num, int pos) {
    return (num >> (8 - pos)) & 1;
}

// Left shift helper
int left_shift(int num, int shifts) {
    return ((num << shifts) | (num >> (5 - shifts))) & 0x1F;
}

// Permutation function
int permute(int input, int* p, int n) {
    int output = 0;
    for (int i = 0; i < n; i++) {
        output <<= 1;
        output |= get_bit(input, p[i]);
    }
    return output;
}

// Key generation: Creates K1 and K2
void generate_keys(int key, int* K1, int* K2) {
    int permuted = permute(key, P10, 10);
    int left = (permuted >> 5) & 0x1F;
    int right = permuted & 0x1F;

    left = left_shift(left, 1);
    right = right_shift(right, 1);
    *K1 = permute((left << 5) | right, P8, 8);

    left = left_shift(left, 2);
    right = right_shift(right, 2);
    *K2 = permute((left << 5) | right, P8, 8);
}

// F-function in S-DES
int f(int right, int subkey) {
    int expanded = permute(right, EP, 8);
    int temp = expanded ^ subkey;

    int left = (temp >> 4) & 0xF;
    int right2 = temp & 0xF;

    int row = ((left & 0x8) >> 2) | (left & 1);
    int col = (left >> 1) & 0x3;
    int s0 = S0[row][col];

    row = ((right2 & 0x8) >> 2) | (right2 & 1);
    col = (right2 >> 1) & 0x3;
    int s1 = S1[row][col];

    int output = (s0 << 2) | s1;
    return permute(output, P4, 4);
}

// S-DES Encryption for one block
int sdes_encrypt_block(int input, int K1, int K2) {
    int temp = permute(input, IP, 8);
    int left = (temp >> 4) & 0xF;
    int right = temp & 0xF;

    int result = left ^ f(right, K1);

    left = right;
    right = result;

    result = (left << 4) | right;
    result = permute(result, IP_inv, 8);

    return result;
}

// CBC mode encryption for n blocks
void cbc_encrypt(uint8_t* plaintext, uint8_t* ciphertext, uint8_t iv, int blocks, int K1, int K2) {
    uint8_t prev = iv;
    for (int i = 0; i < blocks; i++) {
        uint8_t block = plaintext[i] ^ prev;
        ciphertext[i] = sdes_encrypt_block(block, K1, K2);
        prev = ciphertext[i];
    }
}

// CBC mode decryption
void cbc_decrypt(uint8_t* ciphertext, uint8_t* plaintext, uint8_t iv, int blocks, int K1, int K2) {
    uint8_t prev = iv;
    for (int i = 0; i < blocks; i++) {
        uint8_t decrypted = sdes_encrypt_block(ciphertext[i], K2, K1);
        plaintext[i] = decrypted ^ prev;
        prev = ciphertext[i];
    }
}

int main() {
    // Sample test data
    uint8_t plaintext[2] = {0x01, 0x23}; // 00000001 00100011
    uint8_t ciphertext[2];
    uint8_t decrypted[2];
    uint8_t iv = 0xAA; // 10101010
    int K1, K2;
    int key = 0x1FD; // 0111111101

    generate_keys(key, &K1, &K2);

    // CBC Encryption
    cbc_encrypt(plaintext, ciphertext, iv, 2, K1, K2);
    printf("Encrypted blocks: %02X %02X\n", ciphertext[0], ciphertext[1]);

    // CBC Decryption
    cbc_decrypt(ciphertext, decrypted, iv, 2, K1, K2);
    printf("Decrypted blocks: %02X %02X\n", decrypted[0], decrypted[1]);

    return 0;
}
