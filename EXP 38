#include <stdio.h>
#include <stdlib.h>

#define MOD 26

// Function to compute determinant
int determinant(int a, int b, int c, int d) {
    return (a * d - b * c + MOD) % MOD;
}

// Function to compute modular inverse
int mod_inverse(int a) {
    for (int i = 0; i < MOD; i++) {
        if ((a * i) % MOD == 1) {
            return i;
        }
    }
    return -1;
}

// Function to multiply matrices mod 26
void multiply(int key[2][2], int plaintext[2][2], int result[2][2]) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            result[i][j] = (key[i][0] * plaintext[0][j] + key[i][1] * plaintext[1][j]) % MOD;
        }
    }
}

int main() {
    int P[2][2], C[2][2];
    int det, det_inv;
    int key[2][2], adj[2][2], temp[2][2];

    printf("Enter plaintext matrix (2x2) with values (0=A, 1=B, ..., 25=Z):\n");
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            scanf("%d", &P[i][j]);

    printf("Enter ciphertext matrix (2x2) with corresponding values:\n");
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            scanf("%d", &C[i][j]);

    // Step 1: Compute det(P)
    det = determinant(P[0][0], P[0][1], P[1][0], P[1][1]);
    det_inv = mod_inverse(det);

    if (det_inv == -1) {
        printf("Error: Inverse of determinant does not exist. Invalid plaintext matrix.\n");
        return 1;
    }

    // Step 2: Compute adjugate of P
    adj[0][0] = P[1][1];
    adj[0][1] = (MOD - P[0][1]) % MOD;
    adj[1][0] = (MOD - P[1][0]) % MOD;
    adj[1][1] = P[0][0];

    // Step 3: Compute inverse of P
    int inv_P[2][2];
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            inv_P[i][j] = (adj[i][j] * det_inv) % MOD;

    // Step 4: Compute key matrix K = C * inv(P)
    multiply(C, inv_P, key);

    printf("\nRecovered Key Matrix:\n");
    for (int i = 0; i < 2; i++) {
        printf("%d %d\n", key[i][0], key[i][1]);
    }

    // Verify by re-encrypting plaintext
    multiply(key, P, temp);

    printf("\nVerification: ciphertext from recovered key:\n");
    for (int i = 0; i < 2; i++) {
        printf("%d %d\n", temp[i][0], temp[i][1]);
    }

    return 0;
}
