#include <stdio.h>
#include <stdint.h>
#include <string.h>

#define BLOCK_SIZE_64 8
#define BLOCK_SIZE_128 16

// Rb constants for 64-bit and 128-bit blocks
const uint8_t Rb64 = 0x1B;
const uint8_t Rb128 = 0x87;

// Helper: Print block
void print_block(const char *label, const uint8_t *block, int size) {
    printf("%s: ", label);
    for (int i = 0; i < size; i++) printf("%02X", block[i]);
    printf("\n");
}

// Left shift by 1 bit
void left_shift(uint8_t *out, const uint8_t *in, int size) {
    uint8_t carry = 0;
    for (int i = size - 1; i >= 0; i--) {
        uint8_t next_carry = in[i] >> 7;
        out[i] = (in[i] << 1) | carry;
        carry = next_carry;
    }
}

// Mock encryption for demo; replace with AES for actual CMAC
void mock_encrypt_zero_block(uint8_t *out, int size) {
    for (int i = 0; i < size; i++) out[i] = 0xAA + i; // Dummy pattern
}

// Generate subkeys K1, K2
void generate_subkeys(uint8_t *K1, uint8_t *K2, int block_size) {
    uint8_t L[BLOCK_SIZE_128] = {0};
    uint8_t Rb = (block_size == BLOCK_SIZE_64) ? Rb64 : Rb128;

    mock_encrypt_zero_block(L, block_size);
    print_block("L (Enc(0))", L, block_size);

    // Generate K1
    left_shift(K1, L, block_size);
    if (L[0] & 0x80) K1[block_size - 1] ^= Rb;
    print_block("K1", K1, block_size);

    // Generate K2
    left_shift(K2, K1, block_size);
    if (K1[0] & 0x80) K2[block_size - 1] ^= Rb;
    print_block("K2", K2, block_size);
}

int main() {
    uint8_t K1[BLOCK_SIZE_128] = {0};
    uint8_t K2[BLOCK_SIZE_128] = {0};

    printf("=== 64-bit block size ===\n");
    generate_subkeys(K1, K2, BLOCK_SIZE_64);

    printf("\n=== 128-bit block size ===\n");
    generate_subkeys(K1, K2, BLOCK_SIZE_128);

    return 0;
}
