#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

// Compute gcd
uint64_t gcd(uint64_t a, uint64_t b) {
    while (b) {
        uint64_t t = b;
        b = a % b;
        a = t;
    }
    return a;
}

// Extended Euclidean Algorithm to find modular inverse / gcd coefficients
int64_t egcd(int64_t a, int64_t b, int64_t *x, int64_t *y) {
    if (b == 0) {
        *x = 1; *y = 0;
        return a;
    }
    int64_t x1, y1;
    int64_t g = egcd(b, a % b, &x1, &y1);
    *x = y1;
    *y = x1 - (a / b) * y1;
    return g;
}

// Modular inverse
int64_t modinv(int64_t a, int64_t m) {
    int64_t x, y;
    int64_t g = egcd(a, m, &x, &y);
    if (g != 1) return -1; // no inverse
    x %= m;
    if (x < 0) x += m;
    return x;
}

int main() {
    // Example RSA key (Bob's keys)
    uint64_t n = 3599;     // public modulus
    uint64_t e = 31;       // public exponent
    uint64_t d = 3031;     // leaked private exponent

    printf("Public key: (e = %" PRIu64 ", n = %" PRIu64 ")\n", e, n);
    printf("Private key leaked: d = %" PRIu64 "\n\n", d);

    // Step 1: Compute phi(n) from e and d
    uint64_t k = (e * d - 1);  // must be a multiple of phi(n)
    printf("Computing phi(n) from k = e * d - 1 = %" PRIu64 "\n", k);

    uint64_t phi = 0;
    for (phi = 1; phi < n; phi++) {
        if (k % phi == 0) {
            // Test if phi satisfies Euler's formula for 2 primes
            uint64_t s = n - phi + 1;  // s = p + q
            uint64_t discriminant = s * s - 4 * n;
            if (discriminant >= 0) {
                uint64_t t = (uint64_t) sqrt((double) discriminant);
                if (t * t == discriminant) {
                    uint64_t p = (s + t) / 2;
                    uint64_t q = (s - t) / 2;
                    if (p * q == n && p > 1 && q > 1) {
                        printf("Recovered factors of n:\np = %" PRIu64 "\nq = %" PRIu64 "\n", p, q);
                        printf("phi(n) = %" PRIu64 "\n", phi);

                        // Now we can break ANY new RSA keys using this n:
                        uint64_t new_e = 17;  // Bob's "new" public exponent
                        uint64_t new_d = modinv(new_e, phi);
                        printf("\nBob's new (e,d) = (%" PRIu64 ", %" PRIu64 ") using same n\n", new_e, new_d);
                        printf("This is insecure because we already know p and q!\n");
                        return 0;
                    }
                }
            }
        }
    }
    printf("Could not recover factors (something went wrong).\n");
    return 0;
}
